---
title: Frontend Standards
index: 6
---

# Frontend Standards

This is a living document of the standards and best practices used by the IBM Services Engineering team for frontend web development. Our web applications are developed using the latest tools and libraries in the React ecosystem leveraging the latest features of the JavaScript language.

## Core Technologies

- [ES6 JavaScript](https://github.com/lukehoban/es6features)
- [React](https://github.com/facebook/react)
- [Boomerang Create React App](/ise/development/boomerang-create-react-app/)
- [Redux](http://redux.js.org)
- [React Router](https://reacttraining.com/react-router/)
- [Webpack](https://webpack.github.io/)
- [Babel](https://babeljs.io/docs/en/)
- [Jest](https://facebook.github.io/jest/)
- [Cypress](https://www.cypress.io/)
- [Enzyme](http://airbnb.io/enzyme/)
- [React-Testing-Library](https://github.com/testing-library/react-testing-library)
- [Cypress](https://www.cypress.io/)
- [Axios](https://github.com/mzabriskie/axios)
- [json-server](https://github.com/typicode/json-server)
- [Node.js](https://nodejs.org)
- [Express](https://expressjs.com/)
- [Docker](https://www.docker.com/)
- [IBM Cloud Private](https://www.ibm.com/cloud-computing/products/ibm-cloud-private/)

## Webapps

Our web apps are built using React along with other popular packages in the React/Node.js ecosystem.

### Project Structure

React source code files can be found in `src`. We have adopted a group-by-feature project structure that organizes our files into modular features and makes code easier to discover and maintain. We also use the [ducks](https://github.com/erikras/ducks-modular-redux) style of organizing our redux flows. Actions, action types, selectors, thunks, and reducers all sit in a reducer file. This reduces the number of files you need to touch when developing and logically groups the functionality together. We following a nested "fractal" structure for features that places sub-components inside their parents folder. Please see the readings and example structure below that, combined with our project experience, determined the project structure we have adopted on this team.

- [My journey toward a maintainable project structure for React/Redux](https://hackernoon.com/my-journey-toward-a-maintainable-project-structure-for-react-redux-b05dfd999b5)
- [A Better File Structure For React/Redux Applications](https://marmelab.com/blog/2015/12/17/react-directory-structure.html)
- [Three Rules For Structuring (Redux) Applications](https://jaysoo.ca/2016/02/28/organizing-redux-application/)
- [Fractal project structure](https://hackernoon.com/fractal-a-react-app-structure-for-infinite-scale-4dab943092af)

```
api/
cypress/
    |__ fixtures
    |__ integration
        └── tests
    |__ plugins
public/
server/
src/
   |__assets
      |__svg/
         |__boomerang-logo.svg
      |__icons/
         |__BoomerangIcon.js
   |__components/
      |__Navbar/
         |__assets/
            |__boomerang_icon.svg
         |__index.js
         |__index.spec.js
         |__styles.scss

      |__SearchInput/
         |__index.js
         |__index.spec.js
         |__styles.scss
   |__config/
     |__appConfig.js
     |__servicesConfig.js
   |__constants/
     |__requestStatuses.js
   |__features/
      |__App
         |__index.js
         |__index.spec.js
         |__styles.scss
      |__Users/
          |__Header/
            |__index.js
            |__index.spec.js
            |__styles.scss
          |__UsersList/
            |__index.js
            |__index.spec.js
            |__styles.scss
            |__User/
              |__assets/
                |__profile.svg
              |__index.js
              |__index.spec.js
              |__styles.scss
         |__constants/
         |__utilities/
         index.js
         index.spec.js
         styles.scss
   |__state/
      |__users/
         |__index.js
         |__index.spec.js
   |__store/
   |__styles/
      |___styles.scss
      |___variables.scss
      |___base.scss
      |__index.scss
   |__utililties/
     |__helperFunctions.js
   |__index.js
   |__Root.js
server/
```

### Assets

- location of all images in project that are not dynamically loaded and shared across the project
- img.js file to import images into project to be imported in other places in the project
- ImageIcon.js - react component that accepts className as a prop and renders the svg. Useful for images that need to change color on state change, etc.

### Components

Location for components that are not specific to a feature in the application and have some level of resusability. They can be used in other components and shared across projects. React components are capitalized to distinguish them from other .js files and modules.

### Config

Configuration shared across multiple files. Generally these are things like the base url for the services or the root context that the application is being served on.

### Constants

Constants shared across multiple files. Constants that are feature specific should be defined inside the feature folder.

### Features

Features represent a defined set of functionality that is logically linked together and can stand alone in the application. Generally, this is analagous to pages or views. Examples include sign-in, user profile and settings. Feature folders should contain majority of the code needed for that module to work. This includes the container and presentation components, styles and any addtional feature-specific constants, helpers and utilities. Features use the "fractal" folder structure outlined above.

### State

The reducers, following the "ducks" outlined above, are located here along with the root reducer.

### Styles

- Define base css to be used for entire application
- Utilize partials with constants and mixins for things such as color scheme
- Styles for individual components should be defined within the feature and import partials & mixins

### Utilities

Reusable functions such as date conversion and string formatting.

## Serving

Our apps served by a Node.js Express application. See [Boomerang Create React App](/ise/development/boomerang-create-react-app/) for more information.

## Best Practices

Collection of best practices and guiding principles for developing our apps.

### Style Guide

- [Airbnb JavaScript Style Guide() {](https://github.com/airbnb/javascript)
- [Airbnb React/JSX Style Guide](https://github.com/airbnb/javascript/tree/master/react)

### ES6+

Make heavy use of the latest language features of JavaScript. Please see [Boomerang Create React App](/ise-dev/boomerang-create-react-app/) to see what language features are supported.

### Class Properties

Use [class properties](https://michalzalecki.com/react-components-and-class-properties/) to simplify the code and reduce the its surface area. We use it mainly for propTypes, state and bounded functions as seen below.

### PropTypes

If the component receives props, define propTypes. We prefer to include them as an static property on the component so we know immediately what props the component exepcts to receive. From React 15.5 onwards, there is a separate package **'prop-types'** which is to be installed and import PropTypes from there.

```js
import React from "react";
import PropTypes from "prop-types";

class ExampleContainer extends Component {
  static propTypes = {
    name: PropTypes.string
  };

  render() {
    <div>this.prop.name</div>;
  }
}
```

### State and SetState

Using component state in addition to Redux is fine! We declare it as a class property. Please read [below](#Redux-vs-Local-State) about Redux vs Local State. However, you must be careful because setState is executed asynchronously. To avoid any issues with your state updates being batched together, pass a function to setState instead of an object literal.

- [Functional setState() is the Future of React](https://medium.freecodecamp.com/functional-setstate-is-the-future-of-react-374f30401b6b)

```js
class ExampleContainer extends Component {
  state = { count: 0 }

  handleIncrement = () => {
    this.setState((prevState) => (
      {
        count: prevState.count + 1
      }
    ));
  }
...
}
```

### Binding Functions

Use class field functions with arrow functions to remove the need for a consructor and `.bind` on functions that need to have `this` preserved. This improves readability over binding functions in the constructor and obviates the need for the boilerplate code.

```js
class ExampleContainer extends Component {
  state = { count: 0 };

  handleIncrement = () => {
    this.setState(prevState => ({
      count: prevState.count + 1
    }));
  };

  render() {
    <div onClick={this.handleIncrement}>{this.state.count}</div>;
  }
}
```

### Container & Presentational Components

Make heavy use of container & presentational components. Be sure to understand the differences between the two. The article below from the FB React team member and the creator of Redux is required reading. At a high-level, container components are used for connecting to redux store, dispatching actions, handling user interactions with functions & formatting data. They take advantage of the React lifecycle methods and pass props down to presentation components. Presentation components are simply for rendering. Given a set of props, they render accordingly.
[Dan Abramov on component types](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)

### Class Components vs. Stateless Functional Components

Favor stateless functional components (SFC) over class components in presentational components to reduce boilerplate and improve readability. They contain no local state, no lifecycle functions and a limited number of other functions, if any at all. Generally, they receive props and render without side-effects. They are future proof, as new releases of React will distinguish between the functional and class components to improve performance. Use SFC as a starting point and build up from there moving to class components when introducing local state, connecting to the redux store, or utilizing lifecycle methods.

### Redux vs Local State

Use Redux to help reduce the dependency on local state and the potential pitfalls of using it. It does introduce boilerplate so a decision has to be made to determine
whether the trade of is worth it. [Dan Abramov on using redux](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367) Considering the following amongst other considerations:

- Is the component going to be making a network request for data that could be used by another component?
- Is the component going to change the state of the application that will affect other components in the application that aren't in the direct component hierarchy?
- Does Redux introduce enough benefits to the development process such as time-travel debugging to outweigh the boilerplate and indirection it introduces?

### Functional Programming

Make use of the functional programming paradigm when possible. Heavily use array functions `forEach`, `map`, `filter`, `reduce`, `find`, etc. Utilize Higher Order Components (HOCs) when possible for things such as authenticated vs non-authenticated components to reduce code redundancy, such as wrapping a class in a modal or tool tip icon. Use [recompose](https://github.com/acdlite/recompose) utility functions when possible.

### Advance React Component Patterns

Take advantage of advance patterns like function-as-a-child or render props, compound components and the context API. Read more from [Kent Dodds](https://blog.kentcdodds.com/updated-advanced-react-component-patterns-51c34b44b1df)

### HXR & Async Actions

Use [Axios](https://github.com/mzabriskie/axios) to perform network requests and [thunks](https://github.com/gaearon/redux-thunk) middleware to dispatch asynchronous actions. We are exploring [redux-sagas](https://redux-saga.js.org/) as an alternative, but holding off due to thunks meeting our needs and not relying on newer JS language features.

### Linting & Static Type-checking

We use [ESLint](https://github.com/eslint/eslint) as our linting tool with the plugin optionally installed for Visual Studio Code.

Watching both [Flow](https://github.com/facebook/flow) and [TypeScript](https://github.com/Microsoft/TypeScript). Considering TypeScript as it continues to grow in popularity.

### Comments

Use [JSDoc](http://usejsdoc.org/) for commenting your code.

### Hooks

We are in the process of learning and defining standards for [Hooks](https://reactjs.org/docs/hooks-intro.html).

## Patterns

Patterns and components that underpin the Boomerang platform. These patterns and components provide a unified language and consistent look and feel when developing web applications.

### Core Resources

- [Boomerang Components](https://pages.github.ibm.com/Boomerang-Lib/boomerang.package.components)
- [Carbon Components React v6](https://github.com/carbon-design-system/carbon-components-react/tree/v6)
- [Formik](https://github.com/jaredpalmer/formik)
- [IBM Design](https://www.ibm.com/design/language/)
- [Carbon Design System](https://www.carbondesignsystem.com/)

### Empty State

Provide a visual indication that the request for the data for this view was successfully performed, but there is nothing to show.

Components

- NoDisplay
- SVG graphic

Implementation

- Show NoDisplay (or other graphic) component with meaningful message
- Include a call to action if useful in context .e.g. if you are on the components screen, but there aren't any components have a button or link to create one

Example

```javascript
<div>
  {this.props.config.length ? (
    this.props.config.map((input, index) => /* some operations */ );
  ) : (
    <NoDisplay text="Nothing to configure here" />
  )}
</div>
```

### Forms

Components

- Use Formik for input control and validation
- Formik can be used with a complementary package "yup" to build validation schemas.
- Use carbon components for inputs
- Use semantic HTML `<form>` and `<button type="submit">`

Implementation

- Use Formik for setting intial state and schema validation
- Show errors on inputs on blur
- Disable submit button if there are errors
- Dispatch notification on submit for failure and success

Example

```javascript
<Formik
  initialValues={{ label: "", description: "", key: "" }}
  onSubmit={this.handleSubmit}
  validationSchema={Yup.object().shape({
    label: Yup.string().required("Enter a label"),
    key: Yup.string()
      .required("Enter a key")
      .notOneOf(existingKeys, "Key must be unique"),
    description: Yup.string()
  })}
>
  {props => {
    const { values, touched, errors, isSubmitting, isValid, handleChange, handleBlur, handleSubmit } = props;

    if (isSubmitting) {
      return <LoadingAnimation message="We'll be right with you" />;
    }

    return (
      <form onSubmit={handleSubmit}>
        <Body>
          <div className={styles.input}>
            <TextInput
              id="label"
              labelText="Label"
              placeholder="Label"
              value={values.label}
              onBlur={handleBlur}
              onChange={handleChange}
              invalid={errors.label && touched.label}
              invalidText={errors.label}
            />
          </div>
          <div className={styles.input}>
            <TextInput
              id="key"
              labelText="key"
              placeholder="Key"
              value={values.key}
              onBlur={handleBlur}
              onChange={handleChange}
              invalid={errors.key && touched.key}
              invalidText={errors.key}
            />
          </div>
          <div className={styles.input}>
            <TextInput
              id="description"
              labelText="Description"
              placeholder="Description"
              value={values.description}
              onBlur={handleBlur}
              onChange={handleChange}
            />
          </div>
        </Body>
        <Footer>
          <ConfirmButton text="SAVE" type="submit" disabled={!isValid || isSubmitting} />
        </Footer>
      </form>
    );
  }}
</Formik>
```

### Inputs

Components

- Carbon Component React inputs

Implementation

- Use persistent labels for inputs
- Use error handling props
- Use accessibility features by providing id and other props

### Irreversible Actions

If the user is performing an irreversible action or one that has a significant effect on how the platform is used, confirm the actions with a confirmation modal

Component

- AlertModal
- ConfirmModal

Implementation

- Click button to perform action
- See confirmation modal with title and description of action to perform and affirmative and negative action buttons
- On confirm, dispatch notification for success or failure

Example

```javascript
<AlertModal
  modalTrigger={<Button />}
  modalContent={(closeModal, rest) => (
    <ConfirmModal
      closeModal={() => /* close modal operations */ }
      affirmativeAction={() => /* affirmative action operations */ }
      title="Delete"
      subTitleTop="It will be gone. Forever."
      cancelText="NO"
      affirmativeText="YES"
      {...rest}
    />
  )}
/>
```

### Loading

Provide visual indication to the user that something is happening

Components

- LoadingAnimation

Implementation

- Center loading screen in feature or viewport depending on what is being loaded
- Use default delay or greater to prevent flickering on requests that resolve quickly. Default delay to render the LoadingAnimation is 300ms.

Example

```javascript
if (isFetching) {
  return <LoadingAnimation message="We'll be right with you" />;
}

if (status === REQUEST_STATUSES.SUCCESS) {
  /* render component */
}
```

### Handling Errors

Provide visual indication to the user that something went wrong. This can be done using an error component or displaying an error notification.

Components

- ErrorDragon
- NotificationContainer
- Notification
- Notify

Implementation

- Center error component in feature or viewport depending on what errored
- You can see notification implementation and example [here](#notifications)

Example

```javascript
if (status === REQUEST_STATUSES.FAILURE) {
  return <ErrorDragon />;
}

if (status === REQUEST_STATUSES.SUCCESS) {
  /* render component */
}
```

### Modals

Use modal flows as the primary way users "make things happen" in application, preferably for single or small number of step actions that don't require a lot of space or when you don't want to navigate away from the current screen.

Components

- Modal
- ModalBody
- ModalFlow
- ModalFooter
- ModalNavButton
- Notification w/ notify function for dispatching notifications

Implementation

- If user has made a change to the modal and clicks the exit button, confirm the exit with the alert that changes will not be saved. The usefullness of this must be weighed against the possible annoyance caused for the user
- Generally do not allow clicking outside the modal to close it
- Show loading screen after clicking the final action button that makes a request to prevent multiple requests
- Dispatch notifiation on success or error
- On success, close modal
- On error show error in modal with option to try again or start the flow over depending

### Page Not Allowed

### Page Not Found

### Notifications

Use notifications throughout applications to indicate to user that something has occurred.

Components

- NotificationContainer
- Notification
- Notify

Implementation

- On user action that changes the system state e.g. CRUD operation, dispatch notification on success or failure
- If error response includes message and description, include that in the notification
- Use the different types of notification appropriate for the event. See the Boomerang Component libray for the different notification types
- Keep messages concise and action oriented e.g. "Requested submitted" instead of "Your request has been submitted"

Example

```javascript
axios
  .get(url, config)
  .then(() => {
    notify(<Notification type={"success"} title={"Success"} message={"Request Submitted"} />);
  })
  .catch(err => {
    console.log("AXIOS Error :-S", err);
    const { data } = err && err.response;
    notify(<Notification type="error" title={`${data.status} - ${data.error}`} message={data.message} />);
  });
```

### Save and Submit

Provide a visual indication that a network request is being made when a save or submit button is clicked

Components

- Any interactive element, generally a button

Implementation

- Disable element on click until request has been completed
- Change text to indicate action is being performed e.g. "Save" -> "Saving"

Example

```javascript
<Button disabled={isSubmitting} text={isSubmitting ? "SAVING" : "SAVE"} />
```

### State updates

Perform manual state updates when refreshing data is expensive (time intensive) or a bad UX such as it resets filters or is a jarring screen change.

Components

- Redux store
- [Immutability-helper](https://github.com/kolodny/immutability-helper#readme)

Implementation

- When a request to update a resource or change the system state is completed successfully, manually replicate the state change in the Redux store instead of fetching the newly updated data again.
- Use caution when going with this approach as it leads to a more complicated implementation. It is specific to the context and in many situations may be unnecessary.
- Immutability-helper can be used to update the state while avoiding mutation issues.

Example

```javascript
import update from "immutability-helper";

export const initialState = { data: [] };

const actionHandlers = {
  [types.RESET]: () => {
    return { ...initialState };
  },
  [types.DELETE_ACTION]: (state, action) => {
    let deleteIndex;
    state.data.forEach((data, index) => {
      if (data.id === action.dataId) {
        deleteIndex = index;
      }
    });
    return update(state, { data: { $splice: [[deleteIndex, 1]] } });
  }
};

const deleteInStore = dataId => ({ type: types.DELETE_ACTION, dataId });
```

## Styles

### Best Practices

- styles are co-located with components. Keep everything together and avoid styles in one sheet that affect multiple components
- use BEM css class naming and use prefix namespacing
- use `rem` for all things size. Avoid use of `px`. [Why?](https://medium.com/@julienetienne/pixels-are-dead-faa87cd8c8b9)
- avoid nested selectors, ideally one class per component. Sometimes it makes sense to scope child blocks to a parent container class, especially if you are overwriting some styles from a component library
- use `classnames` helper function to apply mulitple classNames to component. e.g. modifiers an themes. It is declarative and less error-prone than manually building a string

### Basic BEM Overview

The [BEM](https://en.bem.info/methodology/) css methodology with namespacing for our CSS helps us create CSS classes that are semantic, reusable, and extendable.

```css
/*represents the top level component */
.block {
}

/*represents a piece of block that helps form it as a whole */
.block__element {
}

/*represents a different state or version of an element */
.block__element--modifier {
}
```

- Keep the names of blocks, elements and modifiers short and semantic.
- Use only Latin letters, dashes and digits.
- Do not use single underscore (\_) or hyphen(-), which are reserved as “separator” characters.
- It is okay to nest blocks inside other blocks! Don't get carried about the the \_\_element modifier

### Namespacing

Namespacing prefixes are used along with BEM in our codebase:

`.c-`  
 Prefix for container classes. Usually used as the top-level of a feature to set up positiong, margin, flex containers, etc. Container classes can be nested within container classes as needed. Flexbox can be very `div` heavy and these classes make it easy to distinguish containers from blocks. They generally don't include styles like colors or fonts, unless you want child elements to inherit some base styles. An example of this could be a base `em` unit so that children can scale differently than the rest of the application as the screen size changes.

`.b-`  
 prefix for a block in a classic BEM sense

`.s-`  
prefix for elements that don't fill well into a block. Usually these are one off elements nested between blocks or at the top level of a container with blocks below.

```scss
.c-user {
  display: flex;
  flex-direction: column;
}
.b-user-header {
  background: $cerulean-70;
  font-color: $white;
}

.b-user-header__name {
  font-size: 1.125rem;
  font-weight: 400;
}

.b-user-header__email {
  font-size: 0.875rem;
  font-weight: 300;
}
```

### Modifiers

Generally because BEM naming is verbose, we add the modifier as a single `--modifier` class instead of repeating the entire classname with the modifier. The following example shows a common use case using the [classnames](https://www.npmjs.com/package/classnames) helper function.

```scss
.b-user-feature__button {
  background-color: $cerulean-70;

  &.--disabled {
    opacity: 0.5;
  }
}
```

```jsx
state={disabled: true }

<button className={classnames("b-user-feature__button", { --disabled: this.state.disabled})}>Click me!</button>
```

```html
<button classname="b-user-feature__button --disabled">Click me!</button>
```

## Unit Testing

We have recently ushered in a new era of testing for our team. We are currently using a combination of [React-Testing-Library](https://github.com/testing-library/react-testing-library), [Jest](https://facebook.github.io/jest/), [Enzyme](http://airbnb.io/enzyme/), and [Cypress](https://www.cypress.io/) for our testing.

- **Jest** - Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications. It is a framework and not a library. It comes with a test runner, assertion library, and good mocking support.

- **React-Testing-Library** - RTL is a relatively new lightweight testing library (not a testing framework) created by Kent Dodds. This library puts an emphasis on testing actual DOM elements. Recently, we have shifted towards writing a majority of our tests with this library and using Jest to run these unit tests.

- **Enzyme** - Enzyme is a JavaScript Testing utility for React that makes it easier to assert, manipulate, and traverse your React Components' output. It is not a unit testing framework. It does not have a test runner or an assertion library. A large number of tests have been written with Enzyme but they are being deprecated in favor of React Testing Library

- **Cypress** - Cypress is an end-to-end UI testing framework. When running a Cypress suite, a visual menu pops up so that you can see the list of commands running sequentially, as well as how the DOM is changing sequentially while running the unit tests. We try to right Cypress tests for major features in our apps.

### Testing Terminology

- Test runner - a tool that picks up files that contain unit tests, executes them, and writes the test results to the console or log files.

- Assertion library - verifies the results of a test.

- Mocks - used in unit testing a component. A component under test has many dependencies. These dependencies are usually replaced by stubs or mocks. Stubs simulate a dependent object.

- Mocking libraries - facilitates the usage of mocks in unit testing.

### Testing Conventions

- Always create one spec file per container or component. This is also evident from the Project structure shown above.

- A test file can contain either ".spec.js" or ".test.js" extension for Jest to detect it as a test file. To maintain consistency in our project we will be using **.spec.js** for all our test files.

- Naming convention for any spec file should be index.spec.js and co-located with the component it is testing. Refer to the project structure above for an example.

- **Snapshot testing** in Jest follows a “green-green-refactor” approach: make the component work, then write a test to take a snapshot, then refactor if necessary.

### Testing methodology

- For a spec file, we will have **describe** blocks for separating our tests.

- These two **describe** blocks below contain a Snapshot test, as well as a block of RTL tests.

```js
import React from "react";
import renderer from "react-test-renderer";
import { render, fireEvent } from "@testing-library/react";
import UserDetailedHeader from "./index";

const props = {
  user: {
    id: "12345",
    email: "boomrng@us.ibm.com",
    name: "Boomerang Joe",
    isFirstVisit: false,
    type: "admin",
    isShowHelp: true,
    firstLoginDate: 1532560199176,
    lastLoginDate: 1533670973670,
    lowerLevelGroupIds: [],
    pinnedToolIds: [],
    favoritePackages: [],
    personalizations: {},
    notificationSettings: {},
    status: "active",
    job: "Software Engineer, CAI",
    pendingRequest: "",
    teams: []
  },
  changeUserRole: jest.fn()
};

describe("User Detailed - Header --- Snapshot", () => {
  it("+++ renders correctly", () => {
    const renderedValue = renderer.create(<UserDetailedHeader {...props} />).toJSON();
    expect(renderedValue).toMatchSnapshot();
  });
});

describe("User Detailed - Header --- RTL", () => {
  it("Opens email modal", () => {
    const { getByText } = render(<UserDetailedHeader {...props} />);
    const modalTrigger = getByText(/Email/i);
    fireEvent.click(modalTrigger);

    expect(getByText(/For when you can't be bothered with Verse/i)).toBeInTheDocument();
  });

  it("Opens role modal", () => {
    const { getByText } = render(<UserDetailedHeader {...props} />);
    const modalTrigger = getByText(/Role/i);
    fireEvent.click(modalTrigger);

    expect(getByText(/change platform role/i)).toBeInTheDocument();
  });

  it("Opens remove modal", () => {
    const { getByText } = render(<UserDetailedHeader {...props} />);
    const modalTrigger = getByText(/Remove/i);
    fireEvent.click(modalTrigger);

    expect(getByText(/Submit a request for this user to be removed from the platform/i)).toBeInTheDocument();
  });
});
```

- **Snapshot** block will contain the Snapshot test(s) for the component. Use **renderer** method of **'react-test-renderer'** for Snapshot test(s). See above for example code. We also make user th

### Best practices

- Add snapshot tests when we are happy with the state of the component. This will give us confidence in the future that the component hasn't changed unintentionally.

- Use the render() method from react-testing-library and pull off query functions from the return object. This allows you to touch elements on the dom based upon various elements (i.e. text, labelText, testId). The [Query Documentation](https://testing-library.com/docs/dom-testing-library/api-queries). The key focus here is testing the components like an end user using it. We dot _not_ want to be testing implementation details that are brittle. We want to focus on building tests that give us high confidence in the quality of our application.

- Reference the [React-Testing-Library API](https://testing-library.com/docs/react-testing-library/api) documentation for other usage questions.

- For major features, use Cypress end-to-end testing in addition to an enzyme snapshot and suite of react-testing-library unit tests.

- Always keep tests simple and maintainble. If a test becomes too complex, it indicates something is awry. Either testing too much or the component needs to broken up.

### Links

- [Testing Training Box Link](https://ibm.ent.box.com/folder/72595188596): contains fundamentals for writing tests in javascript, configurations, react-testing-library and cypress

## Accessibility

Follow industry best practices

- https://reactjs.org/docs/accessibility.html
- https://developer.mozilla.org/en-US/docs/Learn/Accessibility/HTML
- https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/button_role

Use semantic HTML

- Use semantic markup that relates relates markup to content.

Clickable elements

- `<button> or <input type="button">`
- `<div onClick={onClick} onKeyPress={onClick} tabIndex="0" role="button"/>`

Tabbing

- Make sure interactive elements are "tabbable" in a logical order
- Use `tabIndex="0"` for non-semantic html tags

## Contributing

How to manage contributions to a project

### Commit Format

We follow the committing standards set in the [Angular Contribution Guide](https://github.com/angular/angular.js/blob/master/CONTRIBUTING.md#-git-commit-guidelines) and the [Carbon Components Contributing Guide](https://github.com/carbon-design-system/carbon-components-react/blob/master/CONTRIBUTING.md). These standards are enforced with [Husky](https://www.npmjs.com/package/husky), [https://github.com/commitizen/cz-cli](Commitizen) and [validate-commit-msg](https://www.npmjs.com/package/validate-commit-msg).

### Code Formatting

We use [Prettier](https://github.com/prettier/prettier) code formatter to ensure consistancy across our codebases.

### Browser Support

Our apps work best and are tested on the last two versions of the following browsers & OS combinations by default using [Browserlist](https://www.npmjs.com/package/browserslist). Further support can be added as necessary.

- Chrome/macOS Mojave/Winodws 7
- Firefox/macOS Mojave/Winodws 7

### Component Libraries

We've created two component libraries to increase development speed and provide visual and implementation consistency.

We use the [Carbon Design System](https://www.carbondesignsystem.com/) and its [React component library)[https://github.com/carbon-design-system/carbon-components-react]. We created the [Boomerang Carbon Addon Library](https://github.ibm.com/Boomerang-Lib/carbon-addons-boomerang-react) so that wrap their components to add additional functionality and/or styles.

We also use [Boomerang Components](https://github.ibm.com/Boomerang-Lib/boomerang.package.components) for additional components. Here is the storybook: https://pages.github.ibm.com/Boomerang-Lib/boomerang.package.components/. All of our applications were originally written using these components. We are transitioning to use Carbon and Carbon Addons components but this library will remain used in our applications in some capacity for the forseable future.
