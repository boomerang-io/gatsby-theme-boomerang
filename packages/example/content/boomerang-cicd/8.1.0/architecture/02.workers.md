---
title: Worker and Executor Architecture
index: 2
---

# Worker and executor architecture

Following on from the worker infrastructure dependencies mentioned in _Infrastructure Architecture_, the following describes the interaction from Boomerang CICD to the executor architecture and the related workers.

![Boomerang Executor Architecture](./assets/img/boomerang-cicd-architecture-executor.png)

## Executors

Executors allow for a dynamic range of orchestration engines to be used to execute on the activity. This is defined with the Boomerang CICD mode.

- Extensibility through multiple orchestration tools or systems, based on mode
- Swappable implementations
- Current executors: IBM<sup>®</sup> UrbanCode<sup>®</sup> Deploy, and Boomerang Flow
- Source code driven automation enhancing collaboration

## Workers

The default executor is an embedded version of Boomerang Flow bringing a powerful dynamic worker system based on Kubernetes and tightly coupled into the experience. This experience will spin up Kubernetes Jobs for every task in the workflow and map to Configmaps, Secrets, and Persistent Volumes to achieve the end to end automation based on a Boomerang Flow DAG.

See here for more information about how to define your own custom workflows or utilize Boomerang CICD's Smart Stages for defined workflows providing build, test, and deploy automation.

### History

There have been three generations of workers implemented providing an interesting history as to the change in the industry from a server/agent model through to container based execution.

| Generation | Description | 
| --- | --- | --- |
| Gen 1 | This worker ran as part of UrbanCode Deploy and extended the product where UrbanCode Deploy Agents ran inside a container and executed the commands from the centralized server. |
| Gen 2 | A single worker with defined tasks, mapped to each activity of build, test, and deploy. The structure is rigid and tightly coupled to Boomerang CICD activities. | 
| Gen 3 | A dynamic worker system, allowing users to wire together the tasks they want, based on a Boomerang Flow DAG |

### Design guidelines

The current worker design abstracts the complexities of the automation away from the end user. Two out of our three user types are not tailored to use the system to write custom automation.

We design the implementation so that overrides can be provided by the end user, as necessary, to allow some flexibility or customization in the automation. To achieve this, we tend to use the following hierarchy:

- Global overrides that can be passed into the tool, package, or module script being used, usually as CLI flags. A good example is a `debug` type flag that can be passed in to increase the verbosity, or Proxy variables.
- Known overrides that can be passed in by an end user and are default across the spectrum of tools
- The top two or three supported tools and their overrides. A great example is Node.js testing, as there are a number of industry tools, but we choose to support the main industry methods (we don't "boil the ocean"). From there we can add, as required.
- Last fallback is to implement based on a PoV (Proof of Value), with no overrides, and document the dependency that is required.

Additionally, when implementing a mode or piece of functionality, the default approach should be to:

- Auto Detect or Default. A good example is `build.tool`, which is now defaulting for most modes.
- Ask for user input to drive some customization, or
- Make an assumption based on industry best practice or PoV.