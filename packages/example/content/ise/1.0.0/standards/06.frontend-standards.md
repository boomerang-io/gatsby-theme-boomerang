---
title: Frontend Standards
index: 6
---

# Frontend Standards

This is a living document of the standards and best practices used by the IBM Services Engineering team for frontend web development. Our web applications are developed using the latest tools and libraries in the React ecosystem leveraging the latest features of the JavaScript language.

## Core Technologies

- [ES6 JavaScript](https://github.com/lukehoban/es6features)
- [TypeScript](https://www.typescriptlang.org/)
- [React](https://github.com/facebook/react)
- [Create React App](https://create-react-app.dev/)
- [Boomerang Create React App](/ise/development/boomerang-create-react-app/)
- [React Router](https://reacttraining.com/react-router/)
- [Axios](https://github.com/mzabriskie/axios)
- [React-Query](https://www.npmjs.com/package/react-query)
- [Carbon Components React](https://pages.github.ibm.com/Boomerang-Lib/boomerang.package.carbon-addons-boomerang-react)
- [Webpack](https://webpack.github.io/)
- [Babel](https://babeljs.io/docs/en/)
- [Jest](https://facebook.github.io/jest/)
- [React-Testing-Library](https://github.com/testing-library/react-testing-library)
- [Cypress](https://www.cypress.io/)
- [Boomerang json-server](/ise/development/boomerang-packages#boomerang-json-server)
- [Mirage.js](https://miragejs.com/)
- [Node.js](https://nodejs.org)
- [Express](https://expressjs.com/)
- [Docker](https://www.docker.com/)
- [IBM Cloud Private](https://www.ibm.com/cloud-computing/products/ibm-cloud-private/)
- [Carbon Design System](https://www.carbondesignsystem.com)

## Webapps

Our web apps are built using React along with other popular packages in the React/Node.js ecosystem.

### Project Structure

React source code files can be found in `src`. We have adopted a group-by-feature project structure that organizes our files into modular features and makes code easier to discover and maintain. We also use the [ducks](https://github.com/erikras/ducks-modular-redux) style of organizing our redux flows. Actions, action types, selectors, thunks, and reducers all sit in a reducer file. This reduces the number of files you need to touch when developing and logically groups the functionality together. We following a nested "fractal" structure for features that places sub-components inside their parents folder. Please see the readings and example structure below that, combined with our project experience, determined the project structure we have adopted on this team.

- [My journey toward a maintainable project structure for React/Redux](https://hackernoon.com/my-journey-toward-a-maintainable-project-structure-for-react-redux-b05dfd999b5)
- [A Better File Structure For React/Redux Applications](https://marmelab.com/blog/2015/12/17/react-directory-structure.html)
- [Three Rules For Structuring (Redux) Applications](https://jaysoo.ca/2016/02/28/organizing-redux-application/)
- [Fractal project structure](https://hackernoon.com/fractal-a-react-app-structure-for-infinite-scale-4dab943092af)

```sh
api/
cypress/
    |__ fixtures
    |__ integration
        └── tests
    |__ plugins
public/
server/
src/
   |__Assets
      |__svg/
         |__boomerang-logo.svg
      |__icons/
         |__BoomerangIcon.js
   |__Components/
      |__Navbar/
         |__assets/
            |__boomerang_icon.svg
         |__index.js
         |__Navbar.js
         |__Navbar.spec.js
         |__Navbar.module.scss

      |__SearchInput/
         |__index.js
         |__SearchInput.js
         |__SearchInput.spec.js
         |__SearchInput.module.scss
   |__Config/
     |__appConfig.js
     |__servicesConfig.js
   |__Constants/
     |index.js
   |__Features/
      |__App
         |__index.js
         |__App.js
         |__App.spec.js
         |__App.module.scss
      |__Users/
          |__Header/
            |__index.js
            |__Header.js
            |__Header.spec.js
            |__Header.module.scss
          |__UsersList/
            |__index.js
            |__UserList.js
            |__UserList.spec.js
            |__UserList.module.scss
            |__User/
              |__assets/
                |__profile.svg
              |__index.js
              |__Use.js
              |__Users.spec.js
              |__User.module.scss
         |__constants/
         |__utils/
         |__index.js
         |__Users.js
         |__Users.spec.js
         |__Users.module.scss
   |__Hooks/
      |__index.js
      |__useUser.js
   |__State/
      |__users/
         |__index.js
         |__index.spec.js
   |__Store/
   |__Styles/
      |___styles.scss
      |___variables.scss
      |___base.scss
      |__index.scss
   |__Utils/
     |__index.js
     |__helperFunctions.js
   |__index.js
   |__Root.js
server/
```

### Assets

- location of all images in project that are not dynamically loaded and shared across the project
- img.js file to import images into project to be imported in other places in the project
- ImageIcon.js - react component that accepts className as a prop and renders the svg. Useful for images that need to change color on state change, etc.

### Components

Location for components that are not specific to a feature in the application and have some level of reusability. They can be used in other components and shared across projects. React components are capitalized to distinguish them from other .js files and modules.

### Config

Configuration shared across multiple files. Generally these are things like the base url for the services or the root context that the application is being served on.

### Constants

Constants shared across multiple files. Constants that are feature specific should be defined inside the feature folder.

### Features

Features represent a defined set of functionality that is logically linked together and can stand alone in the application. Generally, this is analagous to pages or views. Examples include sign-in, user profile and settings. Feature folders should contain majority of the code needed for that module to work. This includes the container and presentation components, styles and any addtional feature-specific constants, helpers and utilities. Features use the "fractal" folder structure outlined above.

### State

The reducers, following the "ducks" outlined above, are located here along with the root reducer. As a team we have started to moved away from using Redux for state management (except in a few areas). Instead we primarily rely on local state and hooks with the combination of react-query to pull in asynchronous data.

### Styles

- Define base css to be used for entire application
- Utilize partials with constants and mixins for things such as color scheme
- Styles for individual components should be defined within the feature and import partials & mixins

### Utils

Reusable functions such as date conversion and string formatting.

## Webapp Server

Our apps served by a Node.js Express application. See [Boomerang Webapp Server](/ise/development/boomerang-packages#boomerang-webapp-server) for more information.

## Best Practices

Collection of best practices and guiding principles for developing our apps.

### Style Guide

- [Prettier](https://prettier.io/)
- [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)
- [Airbnb React/JSX Style Guide](https://github.com/airbnb/javascript/tree/master/react)
- Use `const CONSTANT =` format for variables assigned to primitive values that do not change
- Use [TypeScript enum format](https://www.typescriptlang.org/docs/handbook/enums.html) for object constants with values that are primitives aka are functionally enums.

```javascript
const PLATFORM_NAME = "Boomerang";

const RequestStatuses = {
  Success: "success",
  Failure: "failure
}

const requestStatusList = [RequestStatuses.Success, RequestStatuses.Failure]
```

### ES6 and Beyond

Make heavy use of the latest language features of JavaScript. Please see [Boomerang Create React App](/ise-dev/boomerang-create-react-app/) to see what language features are supported.

### Class Properties

Use [class properties](https://michalzalecki.com/react-components-and-class-properties/) to simplify the code and reduce the its surface area. We use it mainly for propTypes, state and bounded functions as seen below.

### PropTypes

If the component receives props, define propTypes. We prefer to include them as an static property on the component so we know immediately what props the component exepcts to receive. From React 15.5 onwards, there is a separate package **'prop-types'** which is to be installed and import PropTypes from there.

```js
import React from "react";
import PropTypes from "prop-types";

class ExampleContainer extends Component {
  static propTypes = {
    name: PropTypes.string,
  };

  render() {
    <div>this.prop.name</div>;
  }
}
```

### State and SetState

Using component state in addition to Redux is fine! We declare it as a class property. Please read [below](#Redux-vs-Local-State) about Redux vs Local State. However, you must be careful because setState is executed asynchronously. To avoid any issues with your state updates being batched together, pass a function to setState instead of an object literal.

- [Functional setState() is the Future of React](https://medium.freecodecamp.com/functional-setstate-is-the-future-of-react-374f30401b6b)

```js
class ExampleContainer extends Component {
  state = { count: 0 }

  handleIncrement = () => {
    this.setState((prevState) => (
      {
        count: prevState.count + 1
      }
    ));
  }
...
}
```

### Binding Functions

Use class field functions with arrow functions to remove the need for a consructor and `.bind` on functions that need to have `this` preserved. This improves readability over binding functions in the constructor and obviates the need for the boilerplate code.

```js
class ExampleContainer extends Component {
  state = { count: 0 };

  handleIncrement = () => {
    this.setState((prevState) => ({
      count: prevState.count + 1,
    }));
  };

  render() {
    <div onClick={this.handleIncrement}>{this.state.count}</div>;
  }
}
```

### Container & Presentational Components

Make heavy use of container & presentational components. Be sure to understand the differences between the two. The article below from the FB React team member and the creator of Redux is required reading. At a high-level, container components are used for connecting to redux store, dispatching actions, handling user interactions with functions & formatting data. They take advantage of the React lifecycle methods and pass props down to presentation components. Presentation components are simply for rendering. Given a set of props, they render accordingly. Unless a container component is necessary, our team mostly uses Presentational components.
[Dan Abramov on component types](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)

### Hooks

Learn hooks [Hooks](https://reactjs.org/docs/hooks-intro.html). Use hooks.

Best Practices

- Favor using hooks over HOC's.
- Use hooks from libraries where possible e.g. React Router.
- Be wary of stale closure state. Pay attention to the `react-hooks/exhaustive-deps` warnings. If they annoy you see [React GitHub issue](https://github.com/facebook/create-react-app/issues/6880).
- Don't prematurely optimize with `memoization`. It is an "optimization, not a semantic guarantee". Make sure things work without it.
- Favor `useReducer` over several `useState`s if you have a lot of local state to manage.
- Write custom hooks!

Essential in presentational components, hooks can be used for multiple purposes: state, component updates, and reusable utilities.

## State

useState is the hook provided from React for managing state.

```js
import React, { useState } from "react";

function Example() {
  // Declare a new state variable, which we'll call "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

## Component Updates

useEffect is the hook provided from React that lets you perform side effects in function components.
Listed below is a basic example; although, it is recommended to go through the [Hooks Documentation](https://reactjs.org/docs/hooks-intro.html) if you
are unfamiliar with hooks.

```js
import React, { useState, useEffect } from "react";

function Example() {
  const [count, setCount] = useState(0);

  // Similar to componentDidMount and componentDidUpdate:
  useEffect(() => {
    // Update the document title using the browser API
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

## Custom Hooks

Use hooks to manage and reuse state

```js
// Hook: https://usehooks.com/useHover/
function useHover() {
  const [value, setValue] = useState(false);

  const ref = useRef(null);

  const handleMouseOver = () => setValue(true);
  const handleMouseOut = () => setValue(false);

  useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener("mouseover", handleMouseOver);
      node.addEventListener("mouseout", handleMouseOut);

      return () => {
        node.removeEventListener("mouseover", handleMouseOver);
        node.removeEventListener("mouseout", handleMouseOut);
      };
    }
  }, []);

  return [ref, value];
}
```

### Class Components vs. Functional Components

Favor functional components over class components for new components. When introducing state or lifecycle methods, favor using hooks. We have a large number of class components that are not likely to be rewritten (nor need to be in most cases) with hooks.

## Functional Components vs Arrow Functions

Use `function` notation for React components and use the `arrow function` notation for all other functions in a React component file. This improves readability in our opinion as you can rely on `function` declarations to render something. This becomes especially important if a file contains multiple functional components that my have functions defined inside or outside of them.

Define pure functions outside the scope of the parent component to prevent redeclaration on each render

```js
// pure function outside the scope of the component
const linkHelper = links => {
  // do something here that doesn't use any state
};

function Nav({ links }) {
  const history = useHistory();

  // closed over function that relies on state of the parent component
  const formatLinks = links => {
    const updatedLinks = linkHelper(links);
    //perform operations that uses history state
    ...
  };

  return <Nav items={formatLinks(links)} />;
}
```

### Local State vs Context vs Redux

Favor use of local component state and reducers over gloabal shared state and reducers. Favor user of React context over Redux for shared state. Redux is a last resort for specific use cases. We are still defining what these use cases are for our applications.

Use `react-query` to make network requests and manage data returned, aka "service state".

### Redux considerations

If local state and context don't work for your use case, use Redux. It does introduce boilerplate so a decision has to be made to determine
whether the trade of is worth it. [Dan Abramov on using redux](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367) Considering the following amongst other considerations:

- Is the component going to be making a network request for data that could be used by another component?
- Is the component going to change the state of the application that will affect other components in the application that aren't in the direct component hierarchy?
- Does Redux introduce enough benefits to the development process such as time-travel debugging to outweigh the boilerplate and indirection it introduces?

### Functional Programming

Make use of the functional programming paradigm when possible. Heavily use array functions `forEach`, `map`, `filter`, `reduce`, `find`, etc. Utilize Hooks, Render Props and Higher Order Components (HOCs) when possible for things such as authenticated vs non-authenticated components to reduce code redundancy, such as wrapping a class in a modal or tool tip icon.

### Advance React Component Patterns

Take advantage of advance patterns like function-as-a-child or render props, compound components and the context API. Read more from [Kent Dodds](https://blog.kentcdodds.com/updated-advanced-react-component-patterns-51c34b44b1df).

### HXR & Async Actions

- Use [Axios](https://github.com/mzabriskie/axios) as XHR client
- Use react-query to perform requests
- Favor `async/await` syntax over promise chaining

### React-query

[React-Query](https://www.npmjs.com/package/react-query) is a library based on SWR principle that our team began using and is currently being in-place in our core applications. Check out the documentation to see examples and read more about parameters of the API

**useQuery**

To make an API call, we use the `useQuery` api from react-query. From that we can pass in a query key, as well as a resolver function. The query key provides a cache-able method for re-querying data. The resolver function makes an axios call to the specified service url.

From the function call we can pull off data, status, and error from the useQuery call. A paradigm you will often see in our core applications for the top level components of a feature: we will make a get request for data, is there is an `error` we will display ann error component. We may use `status` to check if the request is loading and show a loading component, then when the `data` is available we will pass that down to child components.

**useMutation**

`useMutation` is the second API call that we make use of from react-query. This api call invokes a resolver function, and then takes a refetchQueries parameter where we pass in the query key that we had already set up. After the resolver function gets called, the API then refreshes the data that we had already received by using `useQuery`.

An example situation where we might use this paradigm: Say we have a feature where we request data to populate a table of users. We would use the `useQuery` call to make that request and set up a unique query key. Then we want to make a delete user request. This would be an example of where we use a `useMutation`. We would pass in the resolver function to make the delete request. Then we would pass in the query key we set up for retrieving the users. After the delete request is made, our users data is refreshed so that our table is also re-rendered with the fresh data.

**invalidateQueries**

`invalidateQueries` is a method in `queryCache` from react-query that can be used to refetch single or multiple queries in the cache based on their query keys or any other functionally accessible property/state of the query. We use it, for example, in the onSuccess function option in `useMutation` for refreshing the data after successfully mutating it.

**setQueryData**

`setQueryData` is a synchronous function in `queryCache` from react-query that allows us to immediately update a query's cached data. We pass the key of the query we want to update and a second parameter that can be either the new data or a function that returns the new data.

An use case is when we need the new data to be shown immediately and don't want to wait for the query to refetch. An example situation would be when the order of certain elements, like cards, are defined by the service and we can reorder them by drag and dropping, triggering a request. When rearranging the cards by dropping one in a new position, we want to keep their new positions while the query is still refetching.

### React Router

- Use hooks
- Use children in Routes

```javascript
// App.js
const { user } = useAppContext()
return <Route path="/teams/:teamName"><Team user={user}/><Route>
// Team.js

const params = useParams();
return <h1>{`Welcome to ${params.teamName}, ${user.name}`}<h1>

```

### Persisting State in URL

Persist search, pagingation, and filtering state in the URL to enhance user experience when appropriate.

- use [query-string](https://www.npmjs.com/package/query-string)
- use of comma delimited values for multiple of one query param e.g. `www.myapp.com/catalog?categories=free,mobile&query=cloud`

### Linting & Static Type-checking

We use [ESLint](https://github.com/eslint/eslint) as our linting tool with the plugin optionally installed for Visual Studio Code.

Watching both [Flow](https://github.com/facebook/flow) and [TypeScript](https://github.com/Microsoft/TypeScript). Considering TypeScript as it continues to grow in popularity.

### Comments

Use [JSDoc](http://usejsdoc.org/) for commenting functions and complex code blocks. Use normal `//` comment format for short inline comments.

## Patterns

Patterns and components that are used for implementing common UI interactions the Boomerang platform. These patterns and components provide a unified language and consistent look and feel when developing web applications.

### Core Resources

- [Carbon Components React](https://github.com/carbon-design-system/carbon/tree/master/packages/react)
- [Carbon Addons Boomerang React](https://pages.github.ibm.com/Boomerang-Lib/boomerang.package.carbon-addons-boomerang-react)
- [Boomerang Utilities](https://pages.github.ibm.com/Boomerang-Lib/boomerang.package.utilities)
- [Formik](https://github.com/jaredpalmer/formik)
- [IBM Design](https://www.ibm.com/design/language/)
- [Carbon Design System](https://www.carbondesignsystem.com/)

### Empty State

Provide a visual indication that the request for the data for this view was successfully performed, but there is nothing to show.

Components

- Error404
- NoData
- SVG graphic

Implementation

- Show Error404 (or other graphic) component with meaningful message
- Include a call to action if useful in context .e.g. if you are on the components screen, but there aren't any components have a button or link to create one

Example

```javascript
<div>
  {this.props.config.length ? (
    this.props.config.map((input, index) => /* some operations */ );
  ) : (
    <Error message="Nothing to configure here" />
  )}
</div>
```

### Forms

Components

- Use Formik for input control and validation
- Formik can be used with a complementary package "yup" to build validation schemas.
- Use carbon components for inputs
- Use semantic HTML `<form>` and `<button type="submit">`
- In `ComposedModal`s and `FlowModal`'s and use a `ModalForm` (all components are from our Carbon Addons Boomerang React library)

Implementation

- Use Formik for setting intial state and schema validation
- Show errors on inputs on blur
- Disable submit button if there are errors
- Dispatch notification on submit for failure and success

Example

```javascript
<Formik
  initialValues={{ label: "", description: "", key: "" }}
  onSubmit={this.handleSubmit}
  validationSchema={Yup.object().shape({
    label: Yup.string().required("Enter a label"),
    key: Yup.string()
      .required("Enter a key")
      .notOneOf(existingKeys, "Key must be unique"),
    description: Yup.string()
  })}
>
  {props => {
    const { values, touched, errors, isSubmitting, isValid, handleChange, handleBlur, handleSubmit } = props;

    if (isSubmitting) {
      return <LoadingAnimation message="We'll be right with you" />;
    }

    return (
      <form onSubmit={handleSubmit}>
        <Body>
          <div className={styles.input}>
            <TextInput
              id="label"
              labelText="Label"
              placeholder="Label"
              value={values.label}
              onBlur={handleBlur}
              onChange={handleChange}
              invalid={errors.label && touched.label}
              invalidText={errors.label}
            />
          </div>
          <div className={styles.input}>
            <TextInput
              id="key"
              labelText="key"
              placeholder="Key"
              value={values.key}
              onBlur={handleBlur}
              onChange={handleChange}
              invalid={errors.key && touched.key}
              invalidText={errors.key}
            />
          </div>
          <div className={styles.input}>
            <TextInput
              id="description"
              labelText="Description"
              placeholder="Description"
              value={values.description}
              onBlur={handleBlur}
              onChange={handleChange}
            />
          </div>
        </Body>
        <Footer>
          <Button type="submit" disabled={!isValid || isSubmitting} > {isSubmitting ?  '...Submitting' : 'Submit'}
        </Footer>
      </form>
    );
  }}
</Formik>
```

### Inputs

Components

- Carbon Component React inputs

Implementation

- Use persistent labels for inputs
- Use error handling props
- Use accessibility features by providing id and other props

### Irreversible Actions

If the user is performing an irreversible action or one that has a significant effect on how the platform is used, confirm the actions with a confirmation modal

Component

- ConfirmModal

Implementation

- Click button to perform action
- See confirmation modal with title and description of action to perform and affirmative and negative action buttons
- On confirm, dispatch notification for success or failure

Example

```javascript
<ConfirmModal
    affirmativeAction={() => /* affirmative action operations */ }
    appElement="#root"
    label="It will be gone. Forever."
    title="Delete?"
    modalTrigger={({ openModal }) => <Button onClick={openModal}>Open confirm modal</Button>}
  >
    <div>additional text that will be rendered</div>
</ConfirmModal>
```

### Loading

Provide visual indication to the user that something is being processed. By default, Loading

Components

- Loading
- DelayRender
- SkeletonPlaceholder
- SkeletonText
- Component-specific skeletons

Implementation

- Use Loading for for application loading including initial requests like for the user, lazy loading of features, form submissions.
- Use skeleton components that match layout of UI to be rendered.
- Use DelayRender wrapper to prevent flickering on requests that resolve quickly. Default delay to render the LoadingAnimation is 300ms. Loading has this built-in.

Application Loading Example

```javascript
if (loadingUser) {
  return <Loading />;
}

if (userData) {
  <p>{`Hello ${userData.name}, welcome to Boomerang. `</p>;
}
```

Feature Loading Example

```javascript
if (loadingTeam) {
  return (<>
          <SkeletonText/>
          <SkeletonPlaceholder />
        </>);
}

if (teamData) {
  <h1>{` ${teamData.name} `</h1>;
  <ul>{teamData.services.map(service => (<li>{service.name}</li>)}</ul>
}
```

### Handling Errors

Provide visual indication to the user that something went wrong. This can be done using an error component or displaying an error notification.

Components

- ErrorMessage
- ErrorDragon
- NotificationContainer
- ToastNotification
- notify()

Implementation

- Center error component in feature or viewport depending on what errored
- ErrorMessage is for minor, feature level errors that don't prevevnt the application from being used
- ErrorDragon is for critical errors that prevent the application or feature from being used .e.g. user data failed to fetch on the initial load. We can't do much then.
- [Notification implementation and example](#notifications)

Minor Error

```javascript
if (pendingMemberError) {
  return <ErrorMessage />;
}

if (pendingMemberData) {
  /* render component */
}
```

Critical Error

```javascript
if (userFailure) {
  return <ErrorDragon />;
}

if (useData) {
  /* render component */
}
```

### Modals

Use modal flows as the primary way users "make things happen" in application, preferably for single or small number of step actions that don't require a lot of space or when you don't want to navigate away from the current screen.

Components

- ComposedModal
- FlowModal
- InlineNotification
- Loading
- ModalForm
- ModalBody
- ModalFooter
- ToastNotification w/ `notify` function for dispatching notifications

Utilities

- formatErrorMessage

Implementation

- If user has made a change to the modal and clicks the exit button, confirm the exit with the alert that changes will not be saved. The usefullness of this must be weighed against the possible annoyance caused for the user.
- Generally do not allow clicking outside the modal to close it.
- Show Loading, disable submit buttton, and change text to action on submit. Do NOT disable cancel button and cancel request on modal close.
- Dispatch ToastNotifiation on success
- Display InlineNotification on error, change form input to "try again" like text. User
- On success, close modal

### Not Allowed

Provide a visual indication that the feature a user is trying to access is not available for them based on role.

Components

- Error403

Implementation

- Show Error403 component with meaningful message
- Include a call to action if useful in context .e.g. don't have access to team, go to home and request to join.

Example

```javascript
if (superSecretFeatureError.status === 403) <Error403 message="Go somewhere to get access" />;
```

### Not Found

Provide a visual indication that the feature a user is trying to access is not available for them based on role.

Components

- Error403

Implementation

- Show Error404 component with meaningful message
- Include a call to action if useful in context .e.g. try refreshing or going back home

Example

```javascript
if (someFeatureError.status === 404) <Error404 message="Hmm can't find this" />;
```

### Notifications

Use in-app notifications throughout applications to indicate to user that something has occurred. Generally, it is showing that a request was recieved and either succeeded or failed.

Components

- InlineNotification
- NotificationContainer
- ToastNotification
- notify()

Utilities

- formatErrorMessage

Implementation

- On user action that changes the system state e.g. CRUD operation, dispatch notification on success or failure
- If error response includes message and description, include that in the notification using `formatErrorMessage` utility
- Use InlineNotifications for forms.
- Use the different types of notification appropriate for the event. See the Boomerang Component libray for the different notification types
- Keep messages concise and action oriented e.g. "Requested submitted" instead of "Your request has been submitted"

Example

```javascript
axios
  .get(url, config)
  .then(() => {
    notify(<Notification type={"success"} title={"Success"} message={"Request Submitted"} />);
  })
  .catch((err) => {
    console.log("AXIOS Error :-S", err);
    const { data } = err && err.response;
    notify(<Notification type="error" title={`${data.status} - ${data.error}`} message={data.message} />);
  });
```

### Save and Submit

Provide a visual indication that a network request is being made when a save or submit button is clicked

Components

- Any interactive element, generally a button

Implementation

- Disable element on click until request has been completed
- Change text to indicate action is being performed e.g. "Save" -> "Saving"

Example

```javascript
<Button disabled={isSubmitting} text={isSubmitting ? "SAVING" : "SAVE"} />
```

### State updates

Perform manual state updates when refreshing data is expensive (time intensive) or a bad UX such as it resets filters or is a jarring screen change.

Components

- Redux store
- [Immutability-helper](https://github.com/kolodny/immutability-helper#readme)

Implementation

- When a request to update a resource or change the system state is completed successfully, manually replicate the state change in the react-query state or Redux store instead of fetching the newly updated data again unncessarily.
- Use caution when going with this approach as it leads to a more complicated implementation. It is specific to the context and in many situations may be unnecessary.
- `immer` and `immutability-helper` can be used to update the state while avoiding mutation issues.

Example

```javascript
import update from "immutability-helper";

export const initialState = { data: [] };

const actionHandlers = {
  [types.RESET]: () => {
    return { ...initialState };
  },
  [types.DELETE_ACTION]: (state, action) => {
    let deleteIndex;
    state.data.forEach((data, index) => {
      if (data.id === action.dataId) {
        deleteIndex = index;
      }
    });
    return update(state, { data: { $splice: [[deleteIndex, 1]] } });
  },
};

const deleteInStore = (dataId) => ({ type: types.DELETE_ACTION, dataId });
```

## Styling

We use a mix of CSS Modules and BEM-style SASS.

### Best Practices

- favor CSS Modules over BEM SASS
- use `classnames` helper library to apply mulitple classNames to component. e.g. modifiers an themes. It is declarative and less error-prone than manually building a string
- styles are co-located with components. Keep everything together and avoid styles in one sheet that affect multiple components
- use BEM css class naming and use prefix namespacing if not using CSS Modules.
- use `rem` for all things size. Avoid use of `px`. [Why?](https://medium.com/@julienetienne/pixels-are-dead-faa87cd8c8b9)
- avoid deeply nested selectors, ideally one class per component. Sometimes it makes sense to scope child blocks to a parent container class, especially if you are overwriting some styles from a component library

### CSS Modules

We use [CSS Modules](https://github.com/css-modules/css-modules) in our applications to automatically scope styles and reduce the mental overhead of writing BEM classes.

- [How to use them in React](https://create-react-app.dev/docs/adding-a-css-modules-stylesheet)
- use descriptive names for class e.g. `deleteButton` vs `button`
- Don't duplicate information in filename that is automatically prefixed to the class name
- Use `:global` prefix to reference external classnames

```css
.container {
  display: flex;
}

.deleteButton {
  width: 10rem;
  :global .bx--btn {
    background: red;
  }
}
```

### Basic BEM Overview [legacy]

The [BEM](https://en.bem.info/methodology/) css methodology with namespacing for our CSS helps us create CSS classes that are semantic, reusable, and extendable.

### BEM Namespacing [legacy]

Namespacing prefixes are used along with BEM in our codebase:

`.c-`  
 Prefix for container classes. Usually used as the top-level of a feature to set up positiong, margin, flex containers, etc. Container classes can be nested within container classes as needed. Flexbox can be very `div` heavy and these classes make it easy to distinguish containers from blocks. They generally don't include styles like colors or fonts, unless you want child elements to inherit some base styles. An example of this could be a base `em` unit so that children can scale differently than the rest of the application as the screen size changes.

`.b-`  
 prefix for a block in a classic BEM sense

`.s-`  
prefix for elements that don't fill well into a block. Usually these are one off elements nested between blocks or at the top level of a container with blocks below.

```scss
.c-user {
  display: flex;
  flex-direction: column;
}
.b-user-header {
  background: $cerulean-70;
  font-color: $white;
}

.b-user-header__name {
  font-size: 1.125rem;
  font-weight: 400;
}

.b-user-header__email {
  font-size: 0.875rem;
  font-weight: 300;
}
```

### Modifiers

Generally because BEM naming is verbose, we add the modifier as a single `--modifier` class instead of repeating the entire classname with the modifier. The following example shows a common use case using the [classnames](https://www.npmjs.com/package/classnames) helper function.

```scss
.b-user-feature__button {
  background-color: $cerulean-70;

  &.--disabled {
    opacity: 0.5;
  }
}
```

```jsx
state={disabled: true }

<button className={classnames("b-user-feature__button", { --disabled: this.state.disabled})}>Click me!</button>
```

```html
<button classname="b-user-feature__button --disabled">Click me!</button>
```

## Unit Testing

We have recently ushered in a new era of testing for our team. We are currently using a combination of:

- [React-Testing-Library](https://github.com/testing-library/react-testing-library)
- [Jest](https://facebook.github.io/jest/)
- [Enzyme](http://airbnb.io/enzyme/)
- [Cypress](https://www.cypress.io/) for our testing.

- **Jest** - Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications. It is a framework and not a library. It comes with a test runner, assertion library, and good mocking support.

- **React-Testing-Library** - RTL is a relatively new lightweight testing library (not a testing framework) created by Kent Dodds. This library puts an emphasis on testing actual DOM elements. Recently, we have shifted towards writing a majority of our tests with this library and using Jest to run these unit tests.

- **Enzyme** - Enzyme is a JavaScript Testing utility for React that makes it easier to assert, manipulate, and traverse your React Components' output. It is not a unit testing framework. It does not have a test runner or an assertion library. A large number of tests have been written with Enzyme but they are being deprecated in favor of React Testing Library

- **Cypress** - Cypress is an end-to-end UI testing framework. When running a Cypress suite, a visual menu pops up so that you can see the list of commands running sequentially, as well as how the DOM is changing sequentially while running the unit tests. We try to right Cypress tests for major features in our apps.

### Testing Terminology

- Test runner - a tool that picks up files that contain unit tests, executes them, and writes the test results to the console or log files.

- Assertion library - verifies the results of a test.

- Mocks - used in unit testing a component. A component under test has many dependencies. These dependencies are usually replaced by stubs or mocks. Stubs simulate a dependent object.

- Mocking libraries - facilitates the usage of mocks in unit testing.

### Testing Conventions

- Always create one spec file per container or component. This is also evident from the Project structure shown above.

- Use `.spec.js` naming convention

- Naming convention for any spec file should be index.spec.js and co-located with the component it is testing. Refer to the project structure above for an example.

- **Snapshot testing** in Jest follows a “green-green-refactor” approach: make the component work, then write a test to take a snapshot, then refactor if necessary.

### Testing methodology

- For a spec file, we will have `describe` blocks for separating our tests.

- These two `describe` blocks below contain a Snapshot test, as well as a block of RTL tests.

```js
import React from "react";
import renderer from "react-test-renderer";
import { render, fireEvent } from "@testing-library/react";
import UserDetailedHeader from "./index";

const props = {
  user: {
    id: "12345",
    email: "boomrng@us.ibm.com",
    name: "Boomerang Joe",
    isFirstVisit: false,
    type: "admin",
    isShowHelp: true,
    firstLoginDate: 1532560199176,
    lastLoginDate: 1533670973670,
    lowerLevelGroupIds: [],
    pinnedToolIds: [],
    favoritePackages: [],
    personalizations: {},
    notificationSettings: {},
    status: "active",
    job: "Software Engineer, CAI",
    pendingRequest: "",
    teams: [],
  },
  changeUserRole: jest.fn(),
};

describe("User Detailed - Header --- Snapshot", () => {
  it("+++ renders correctly", () => {
    const renderedValue = renderer.create(<UserDetailedHeader {...props} />).toJSON();
    expect(renderedValue).toMatchSnapshot();
  });
});

describe("User Detailed - Header --- RTL", () => {
  it("Opens email modal", () => {
    const { getByText } = render(<UserDetailedHeader {...props} />);
    const modalTrigger = getByText(/Email/i);
    fireEvent.click(modalTrigger);

    expect(getByText(/For when you can't be bothered with Verse/i)).toBeInTheDocument();
  });

  it("Opens role modal", () => {
    const { getByText } = render(<UserDetailedHeader {...props} />);
    const modalTrigger = getByText(/Role/i);
    fireEvent.click(modalTrigger);

    expect(getByText(/change platform role/i)).toBeInTheDocument();
  });

  it("Opens remove modal", () => {
    const { getByText } = render(<UserDetailedHeader {...props} />);
    const modalTrigger = getByText(/Remove/i);
    fireEvent.click(modalTrigger);

    expect(getByText(/Submit a request for this user to be removed from the platform/i)).toBeInTheDocument();
  });
});
```

- **Snapshot** block will contain the Snapshot test(s) for the component. Use appropriate **render** method of **'React-Testing-Library'** or **react-test-renderer** for Snapshot test(s). See above for example code.

### Best practices

- Favor using react-testing-library for unit tests over Enzyme.

- Use preconfigured rendering methods that wrap Redux and React Router. This makes your unit tests as close to the real use of the components as possible.

  - renderWithProvider
  - renderWithRouter
  - renderWithProviderAndRouter

- Add snapshot tests when we are happy with the state of the component. This will give us confidence in the future that the component hasn't changed unintentionally.

- Use the render() method from react-testing-library and pull off query functions from the return object. This allows you to find elements on the dom based upon various elements (i.e. text, labelText, testId). The [Query Documentation](https://testing-library.com/docs/dom-testing-library/api-queries). The key focus here is testing the components like an end user using it. We dot _not_ want to be testing implementation details that are brittle. We want to focus on building tests that give us high confidence in the quality of our application.

- Reference the [React-Testing-Library API](https://testing-library.com/docs/react-testing-library/api) documentation for other usage questions.

- Read [Common mistakes with React Testing Library](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)

- For major features, use `Cypress` end-to-end testing in addition to a snapshot and suite of react-testing-library unit tests.

- Always keep tests simple and maintainble. If a test becomes too complex, it indicates something is awry. Either testing too much or the component can be broken up.

- If the project uses `Mirage.js`, use that for network requests. If it using `Json-Server`, use [mock-axios-adapter](https://github.com/ctimmerm/axios-mock-adapter).

### Links

- [Testing Training Box Link](https://ibm.ent.box.com/folder/72595188596): contains fundamentals for writing tests in javascript, configurations, react-testing-library and cypress

## Accessibility

### Industry best practices

Follow them.

- [React Docs Accessibilty](https://reactjs.org/docs/accessibility.html)
- [MDN Accessibilty](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/HTML)
- [MDN ARIA Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/button_role)

Use semantic HTML

- Use semantic markup that relates relates markup to content. This will save you from having to reimplement a lot of browser accessibility features you get for free by using the correct tag for the job.

Clickable elements

- `<button> or <input type="button">`
- `<div onClick={onClick} onKeyPress={onClick} tabIndex="0" role="button"/>`

Tabbing

- Make sure interactive elements are "tabbable" in a logical order
- Use `tabIndex="0"` for non-semantic html tags

### Links

- Follow default link behavior in most situations. Don't open in a new tab. Don't break the web, man.
- New window/tab guidelines:
  - Visually call out that the link opens in a new link
  - Add aria attributes to announce to screen readers that the link behavior. See example below.
  - Use `rel="noopener noreferrer"` for security.
  - [W3C Guidelines](https://www.w3.org/TR/WCAG20-TECHS/G201.html)
  - [Why let someone know when a link opens a new window?](https://medium.com/@svinkle/why-let-someone-know-when-a-link-opens-a-new-window-8699d20ed3b1)

```html
<!-- index.html -->
<div hidden>
  <span id="new-window-aria-desc-0">Opens in a new tab</span>
</div>
```

```javascript
<p>
  View our{" "}
  <a
    aria-describedby="new-window-aria-desc-0"
    href={`${BASE_LAUNCH_ENV_URL}/docs/boomerang/architecture/security-architecture`}
    target="_blank"
    rel="noopener noreferrer"
  >
    documentation
    <Launch16 fill="#78a9ff" />
  </a>{" "}
  for detailed information on scopes.
</p>
```

## Contributing

How to manage contributions to a project

### Branching

Follow a feature branching strategy and include the project key and number in the branch name e.g. `feature-PLT-1000-myGreatFeature`

### Commit Format

We follow the committing standards set in the [Angular Contribution Guide](https://github.com/angular/angular.js/blob/master/CONTRIBUTING.md#-git-commit-guidelines) and the [Carbon Components Contributing Guide](https://github.com/carbon-design-system/carbon-components-react/blob/master/CONTRIBUTING.md). These standards are enforced with [Husky](https://www.npmjs.com/package/husky), [https://github.com/commitizen/cz-cli](Commitizen) and [validate-commit-msg](https://www.npmjs.com/package/validate-commit-msg).

### Code Formatting

We use [Prettier](https://github.com/prettier/prettier) code formatter to ensure consistancy across our codebases. It is run on changed files on each commit via pre-commit hooks.

## Pull Requests

- Use GitHub PR template
- Use PR checks to perform testing and other checks on code before merging in
- Have multiple team members approve PR

### Browser Support

Our apps work best and are tested on the last two versions of the following browsers & OS combinations by default using [Browserlist](https://www.npmjs.com/package/browserslist). Further support can be added as necessary.

- Chrome/macOS/Windows
- Firefox/macOS/Windows
- Safari/macOS

## Versioning

Follow [SemVer](https://semver.org/)

### Component Libraries

We've created two component libraries to increase development speed and provide visual and implementation consistency.

We use the [Carbon Design System](https://www.carbondesignsystem.com/) and its [React component library)[https://github.com/carbon-design-system/carbon/tree/master/packages/react]. We created the [Boomerang Carbon Addons Library](https://github.com/boomerang-io/carbon-addons-boomerang-react) to add additional functionality and styles.
